---
title: Porting Guide
layout: documentation
---

<p>An AsteroidOS hardware adaptation layer consists of :</p>
<ul>
<li>OpenEmbedded recipes describing the compilation of the various HW adaptation components.</li>
<li>An appropriate vendor kernel able to boot the watch’s SoC and including the required drivers.</li>
<li>A set of Wear OS’s proprietary binary blobs used through libhybris in order to access some of the Android’s HALs.</li>
<li>Some middleware configuration files to use your HW adaptation.</li>
</ul>
<div class="markdown-body">
<div class="page-header">
  <h1 id="oebsplayer">Creating an OpenEmbedded BSP layer</h1>
</div>
<p>In order to add the support of&nbsp;your watch to AsteroidOS, you’ll need to write an OpenEmbedded layer. Start&nbsp;by making sure you are familiar with the core concepts behind OpenEmbedded by reading the two related documentation pages.</p>
<ul>
<li><a href="{{rel 'wiki/openembedded'}}">OpenEmbedded</a></li>
<li><a href="{{rel 'wiki/building-asteroidos'}}">Building AsteroidOS</a></li>
</ul>
<p>The easiest way to create an OpenEmbedded layer for hardware adaptation is to modify one that already exists. If you want to base your port on an Android 5.5.1 base, you should base your layer&nbsp;on <a href="https://github.com/AsteroidOS/meta-dory-hybris">meta-dory-hybris</a>. If you want to base your port on an Android 6 base, you should base your layer on <a href="https://github.com/AsteroidOS/meta-swift-hybris">meta-swift-hybris</a>. If you want to base your port on an Android 8 base, you should base your layer on <a href="https://github.com/AsteroidOS/meta-mooneye-hybris">meta-mooneye-hybris</a>.</p>
<p>Start by cloning the most appropriate layer into an src/meta-XXX-hybris/ directory in your AsteroidOS build tree. From now on, XXX will be a reference to&nbsp;your watch’s codename. Once you have that layer setup, <a href="https://github.com/AsteroidOS/meta-swift-hybris/commit/b665878f80936f21cec1757cdc4d10fa95af1841">roughly&nbsp;replace</a> all references to the previous codename&nbsp;with XXX in the layer and add the path to your layer in your build/conf/bblayers.conf file.</p>
<p>The&nbsp;layer should describe&nbsp;a machine configuration to bitbake in&nbsp;<a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/conf/machine/dory.conf">conf/machine/XXX.conf</a>. The definition of a machine allows to <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/conf/machine/dory.conf#L25">install hardware-specific packages</a>&nbsp;in a generated rootfs and&nbsp;to give very general information about the hardware adaptation like the <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/conf/machine/dory.conf#L18">kernel</a> or <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/conf/machine/dory.conf#L10">egl providers</a>&nbsp;that should be used. Having a new machine also allows to modify other layers’&nbsp;recipes based on the build’s target. For example a .bbappend file using the _XXX suffix appropriately can&nbsp;<a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-android/brcm-patchram-plus/brcm-patchram-plus_git.bbappend#L1">modify built files</a>, <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-qt/qt5/qt5-qpa-hwcomposer-plugin_git.bbappend#L1">apply&nbsp;patches</a>,&nbsp;<a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-nemomobile/sensorfw/sensorfw_git.bbappend#L1">add build dependencies</a>, <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-multimedia/pulseaudio/pulseaudio_%25.bbappend#L1">add runtime dependencies</a> or&nbsp;<a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-android/brcm-patchram-plus/brcm-patchram-plus_git.bbappend#L3">change compilation flags</a>. bbappends are very powerful but&nbsp;should be used scarcely to&nbsp;avoid conflicts with other layers.</p>
<p>An hardware adaptation layer does not only modify other recipes with bbappend, it also provides a couple of new recipes that are hardware-specific. You can usually find two very important recipes: the <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory_lp-mr1.bb">kernel recipe</a> and the <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-android/android/android_dory-lp.bb">Android’s blobs recipe</a>. Those recipes will need extra-care and are the topic&nbsp;of the two following paragraphs.</p>
<div class="page-header">
  <h1 id="kernelrecipe">Creating an appropriate Linux kernel recipe</h1>
</div>
<p>The kernel recipe describes how to fetch/patch/configure/compile/install/package the vendor kernel. All of those steps may need to be modified from your base recipe.</p>
<p>First of all, you need to find the <a href="https://android.googlesource.com/kernel/msm/+refs">git repository</a>, branch and commit containing the source code of the watch you want to work on.&nbsp;Adapt <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory_lp-mr1.bb#L11">SRC_URI</a> and <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory_lp-mr1.bb#L16">SRCREV</a> accordingly.</p>
<p>Then, try to find your watch’s <a href="https://android.googlesource.com/kernel/msm/+/android-msm-dory-3.10-marshmallow-mr1-wear-release/arch/arm/configs/dory_defconfig">defconfig</a> in the kernel’s&nbsp;arch/arm/configs/ directory.&nbsp;Copy this base defconfig onto <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory/defconfig">meta-XXX-hybris/recipes-kernel/linux/linux-XXX/defconfig</a>&nbsp;and use the <a href="https://github.com/AsteroidOS/meta-asteroid/blob/master/scripts/check-config">check-config script of meta-asteroid</a> with the -w flag to fix a couple of configuration values.</p>
<p>If you need to patch your kernel’s tree, add the path to <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory/0001-Backport-mainline-4.1-Bluetooth-subsystem.patch">the patches</a> to <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory_lp-mr1.bb#L14">SRC_URI</a>.</p>
<p>The output of a kernel compilation is a single zImage. In order to be started by your watch’s bootloader, this image needs to be packed with an initramfs into a single boot.img file. (for more information cf.&nbsp;<a href="{{rel 'wiki/boot-process'}}">Boot Process</a>) Three different tools can be used to pack the boot.img file: abootimg, mkboot and mkbootimg. Since some watches only work with one of those tools (without any apparent reason), you can <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory_lp-mr1.bb#L36">inherit</a> one of the <a href="https://github.com/AsteroidOS/meta-asteroid/tree/master/classes">provided bbclass</a>&nbsp;and adapt the config accordingly.</p>
<p><strong>Extra-Note</strong>: The Yocto project provides a <a href="http://www.yoctoproject.org/docs/1.6.1/kernel-dev/kernel-dev.html">handy manual</a> on how to work with the Linux kernel with OpenEmbedded.</p>
<div class="page-header">
  <h1 id="systemdir">Building the Android's /system/ directory</h1>
</div>
<p>In order to get a full AsteroidOS environment, you will need to install the Android HALs required&nbsp;by the usage of libhybris in various AsteroidOS components.</p>
<p>Actually, only a very limited set of libs from Android is needed. Some of those libs (like bionic) need to be patched and must be recompiled from source. Hence, you’ll need to start by cloning a <a href="https://github.com/AsteroidOS/android_manifest/blob/master/default.xml">modified and stripped down Android source tree</a> to compile the needed drivers. You can find detailed info on the build process&nbsp;that has been used for dory in <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/README-system-dir">README-system-dir</a>. You’ll most likely need to adapt those instructions to your own need, thus you are strongly encouraged to document your steps in your own README-system-dir for reproducibility and in order to help future porters.</p>
<p>Once you’ll get your first /system/ directory, you can modify meta-XXX-hybris/recipes-android/android/android_XXX-*.bb to use your&nbsp;prebuilt tarball. The next steps in hardware adaptation will most likely require you to iterate various modifications to&nbsp;this system directory so don’t get too emotionally attached to this tarball yet.</p>
<div class="page-header">
  <h1 id="boot">Boot</h1>
</div>
<p>If you boot your generated boot.img from your watch’s bootloader, fastboot should load your kernel which will load the initramfs’s init script which will eventually load you rootfs’s init system.&nbsp;(for more information cf.&nbsp;<a href="{{rel 'wiki/boot-process'}}">Boot Process</a>) You can usually know if those steps have successfully been completed when the watch stays up and running and shows the AsteroidOS boot logo for a while (shown by psplash which is ran by systemd on the rootfs). In case your boot stops earlier, you have a boot problem to debug.</p>
<p>You need to proceed by elimination to find what causes your boot to fail. First of all, disable the ramfs -&gt; rootfs switch&nbsp;by adding a bash infinite loop early&nbsp;<a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-core/initrdscripts/initramfs-boot-android/init.sh#L54">in your ramdisk’s init script</a>. If you notice your watch does not crash anymore, you may have an issue with your rootfs. The Troubleshooting section of the <a href="{{rel 'wiki/boot-process'}}">Boot Process page</a> should help you retrieve your systemd logs and isolate the cause of your boot problem.</p>
<p>If your watch keeps on crashing, you may have a problem with your kernel. Start by making&nbsp;sure you tried the different boot.img packing tools. If the problem persists, you’ll want to retrieve your kernel’s message logs. This can usually be retrieved from a /proc/last_kmsg virtual file in Wear OS when enabling the&nbsp;CONFIG_ANDROID_RAM_CONSOLE kernel option. Analyzing the logs should also help narrowing down the issue to a faulty driver or config.</p>
<div class="page-header">
  <h1 id="usb">USB</h1>
</div>
<p>If you have your AsteroidOS system running, you will want to get a shell access to it with adb or SSH over USB. Use <i>dmesg -w</i> on your computer to check if your watch appears after having been booted for a few seconds. If you don’t see your watch, you may have a problem with your USB setup.</p>
<p>First of all, try to replicate the config of your Wear OS’s init scripts in <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-core/initrdscripts/initramfs-boot-android/init.sh#L26">your ramdisk’s init script</a>. Once you’re sure the USB config is the same, you should try to run <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-core/initrdscripts/initramfs-boot-android/init.sh#L52">adbd from your ramdisk</a> instead of the rootfs, if it solves the problem you may have an issue with usb_moded not starting adbd or RNDIS properly.</p>
<p>If the problem is the same, you may have a problem with your kernel’s config or drivers. First of all, make sure CONFIG_USB_G_ANDROID is still enabled in the generated build/tmp-glibc/work/XXX-oe-linux-gnueabi/linux-XXX/*/git/.config as it is quite common to find bitbake removing this option. If the option is still there, your kernel may need special patches.</p>
<div class="page-header">
  <h1 id="display">Display</h1>
</div>
<p>As soon as you’ll get access to a shell on AsteroidOS, you may&nbsp;find yourself without asteroid-launcher running. Checking the system logs with “journalctl –no-pager” or “systemctl –no-pager” usually shows a segfault from the lipstick process. This is to be expected on your first run and there is nothing to worry about. In order to reproduce the bug, you can start lipstick manually with:</p>
<p>XDG_RUNTIME_DIR=/run/user/1000 EGL_PLATFORM=hwcomposer lipstick –platform hwcomposer</p>
<p>asteroid-launcher uses lipstick which uses the hwcomposer QPA which uses libhybris which uses the Android graphic HAL to display things on screen. You may need to adapt&nbsp;the Android graphic HAL to answer the needs of hybris. (usually a matter of starting the right android boot services, having the right files placed in the right directories, having the right system.prop options etc…)</p>
<p>For more information on the Graphic Stack you may want to refer to <a href="{{rel 'wiki/graphic-stack'}}">the associated documentation page</a>. For more information on how to debug an&nbsp;issue, check the Troubleshooting paragraph of this page.</p>
<div class="page-header">
  <h1 id="touch">Touch</h1>
</div>
<p>Once you’ll get asteroid-launcher displaying things on screen, you may have no touch feedback from the UI. If that is the case, you’ll need to modify the lipstick’s start command to use a different evdevtouch file. For example, tetra uses <a href="https://github.com/AsteroidOS/meta-tetra-hybris/tree/master/recipes-asteroid/asteroid-launcher">this bbappend</a> to use /dev/input/event1 instead of the default event0.</p>
<div class="page-header">
  <h1 id="audio">Audio</h1>
</div>
<p>Smartwatches usually don’t carry&nbsp;speakers but they often have microphones. AsteroidOS does not use those microphones yet but it’s usually easy to support and should be supported&nbsp;for the future of the project. AsteroidOS uses <a href="https://github.com/AsteroidOS/meta-asteroid/tree/master/recipes-multimedia/pulseaudio">pulseaudio</a> for its audio stack. pulseaudio takes benefits from the pulseaudio-droid-card module to use the Android’s Audio HAL.&nbsp;In order to test the microphone, you can install and run parec from the build/tmp-glibc/work/armv7ve-neon-oe-linux-gnueabi/pulseaudio/9.0-r0/packages-split/pulseaudio-misc/ package. If you lack an audio interface, make sure you <a href="https://github.com/AsteroidOS/meta-dory-hybris/commit/0276357cdb266ce28eb37ca958c70f5273d588cd">loaded the audio firmware</a>.</p>
<p>In case a problem persist, enabling <a href="https://wiki.ubuntu.com/PulseAudio/Log">extra debug information</a> from pulseaudio can give you detailed info on the cause of the issue.</p>
<div class="page-header">
  <h1 id="bluetooth">Bluetooth</h1>
</div>
<p>Smartwatches make&nbsp;extensive use of Bluetooth for connectivity. The AsteroidOS project comes with a set of Bluetooth Low Energy profiles implemented in the asteroid-btsyncd server daemon and AsteroidOSSync client.&nbsp;(for more information cf.&nbsp;<a href="{{rel 'wiki/bluetooth/'}}">Bluetooth</a>) Bluetooth required a few extra steps to work on your port.</p>
<p>asteroid-btsyncd uses BlueZ’s DBus API to create a BLE server. Those APIs require a recent Bluetooth subsystem in your kernel. Unfortunately, Wear OS watches usually come with outdated kernels and a newer BT subsystem needs to be backported. The patch used in dory can be found <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory/0001-Backport-mainline-4.1-Bluetooth-subsystem.patch">here</a>&nbsp;and should be adaptable to your kernel’s tree with very few&nbsp;conflicts.</p>
<p>Most Wear OS smartwatches carry a Broadcom BT chip that requires&nbsp;a proprietary firmware to be applied with a tool named brcm-patchram-plus. This tool is called from a systemd service named patchram.service, your HW adaptation layer should include a <a href="https://github.com/AsteroidOS/meta-dory-hybris/tree/master/recipes-android/brcm-patchram-plus">modified patchram.service</a> file that uses the provided vendor’s firmware and tty line. Information about the config you should use can be found in the <a href="https://android.googlesource.com/platform/hardware/broadcom/libbt/+/master/include/">Android’s libbt-broadcom repository</a>.</p>
<p>With a backported BT subsystem and patched BT firmware, you should already be able to get Bluetooth connectivity on your port but with very limited battery life. Broadcom’s bluetooth’s low power mode&nbsp;is handled by a kernel module named Bluesleep (or more recently Nitrous) that expects custom information to be written in /proc/lpm/. With BlueZ, this proc interface is never used hence the kernel driver must be adapted to receive HCI events from the BT subsystem with <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-kernel/linux/linux-dory/0002-bluesleep-Use-kernel-s-HCI-events-instead-of-proc-bl.patch">a patch</a>. Finally, brcm-patchram-plus must also be <a href="https://github.com/AsteroidOS/meta-dory-hybris/blob/master/recipes-android/brcm-patchram-plus/brcm-patchram-plus_git.bbappend#L3">compiled with a special flag</a> defining the target device and the <a href="https://github.com/AsteroidOS/brcm-patchram-plus/commit/94fb127e614b19a9a95561b8c1a0716e2e1e6293">low power mode options to use</a>.</p>
<div class="page-header">
  <h1 id="sensors">Sensors</h1>
</div>
<p>In AsteroidOS, sensors can be used by developers through the QtSensors API that uses the sensorfw backend. Sensorfwd is a sensor daemon that can use libhybris to interface with the Android’s Sensors HAL.</p>
<p>In order to use sensors on AsteroidOS, you need to make sure libhybris recognizes your sensors by running the test_sensors command.&nbsp;For some platforms it is required to start a sensor daemon.&nbsp;This can usually be found in Wear OS's init scripts.&nbsp;A likely output of test_sensor for a platform needing a sensor daemon is:</p>
<p>sensors_open() failed: Operation not permitted</p>
<p>For more information on how to debug an&nbsp;issue, check the Troubleshooting paragraph of this page.</p>
<div class="page-header">
  <h1 id="haptics">Haptics</h1>
</div>
<p>In AsteroidOS, vibrations&nbsp;can be used by developers through the QtFeedback and ngfd&nbsp;APIs that usually rely on a libhybris backend which uses the Android’s vibration HAL.</p>
<p>In order to use vibration&nbsp;on Asteroid with the Android HAL, you need to make sure libhybris recognizes your vibrator by running the test_vibrator command.&nbsp;For more information on how to debug an&nbsp;issue, check the Troubleshooting paragraph of this page.</p>
<p>A much cleaner way to vibrate in AsteroidOS would be to use an ffmemless kernel driver and the sensorfwd’s ffmemless backend but most watches don’t come with such a kernel driver and it would need to be developed.</p>
<div class="page-header">
  <h1 id="wlan">WLAN</h1>
</div>
<p>WLAN is not used by AsteroidOS’s user-interface yet but it should be supported for the future of the project. Some information about setting up a Wi-Fi interface can be found in the last paragraph of the <a href="{{rel 'wiki/ssh'}}">SSH documentation page</a>.</p>
<div class="page-header">
  <h1 id="troubleshooting">Troubleshooting</h1>
</div>
<p>While porting AsteroidOS to your watch, you will most likely meet all kind of problems. In order to debug what’s going wrong with your setup you should install debug tools such as strace and gdb and the required debug sybols to your generated rootfs. For example, you can temporarily append the “strace gdb asteroid-launcher-dbg” packages to the <a href="https://github.com/AsteroidOS/meta-asteroid/blob/master/classes/asteroid-image.bbclass#L9">asteroid-image class</a>.</p>
<p>Once you come up with more information about your bug with strace and gdb, your first reflex should be to <a href="https://log.asteroidos.org/search">search&nbsp;the asteroid’s IRC logs</a> for similar issues. The SailfishOS porters community is another great place to search for information, you may also want to try your chance at <a href="https://www.google.com/search?q=site%3Amerproject.org+irc+QCOM_BSP">searching the merproject’s IRC logs</a>.</p>
<p>If you still couldn’t find a solution to your problem in the logs, don’t hesitate to ask questions on&nbsp;the #asteroid IRC channel. There should be&nbsp;several porters able to help you.</p>
<div class="page-header">
  <h1 id="upstreamyourwork">Upstream your work</h1>
</div>
<p>That’s it, you can finally use AsteroidOS on your watch! Sharing your work with the rest community should be the final step to ensure your layer will be maintained through&nbsp;time.&nbsp;Start by requesting on IRC the creation of a new AsteroidOS/meta-XXX-hybris repository and send a pull request to this repository. Your work will be carefully reviewed and commented before being integrated upstream. You’ll also need to send a <a href="https://github.com/AsteroidOS/asteroid/pull/8">pull-request to the AsteroidOS/asteroid repository</a>&nbsp;to integrate your machine to prepare-build.sh and join the very privileged circle of AsteroidOS porters! Make sure your work is correctly detailed on the <a href="{{rel 'wiki/porting-status'}}">Porting Status</a> page and share a photo of your watch for public twitter announcement.</p>
</div>
